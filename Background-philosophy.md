
# Background philosophy

## Introduction

In 1961, NASA set out on a mission to send a manned rocket to the moon, Apollo 11, however, the calculations were far too complex to do by hand. As a result, NASA designed the Apollo Guidance Computer to do these calculations. In the modern day, a typical smartphone is millions times faster than NASA's computers were in 1969. Considering the math NASA had done with these computers, there should be more software developed today than there is, however, it is difficult as an individual has to spend a significant amount of time learning the architure of a piece of software to use it. In other words, general-purpose computing today is not efficient because the UNIX philosophy is absent in software.

## Main

In the 1970's, before major projects like MySQL, JBoss and Android existed, creators of the UNIX operating system *(the root of most operating systems in the world)* believed that software should work together and be easily usable. Today, it is mostly impossible for an individual to develop a major search engine, video game, computational tool or anything because software is difficult to use. This is because an individual has to solve problems based on the different paradigms of software to compute efficiently, which includes, for example, the aspects of an API, fundamental principles of a programming language or layers of a database.

These problems exist because software is non-communicable. In other words, the UNIX philosophy is absent in it. This is because of practically all software has specific architecture to an extent. Even though architecture is an inevitable part of software development, in theory it does not allow progressive computing. In other words, it has no relation to the UNIX philosophy. For example, an individual can develop a codebase of tools for his next major application, however, his development and even general-purpose use of a computer will be "tied" to that application. The individual will not be able to compute and develop other software efficiently because the codebase will not respect the UNIX philosophy. Architecture is the biggest problem in general-purpose computing. To make general-purpose computing efficient, the core principles of computing (i.e. the UNIX philosophy) must be applied to it.
